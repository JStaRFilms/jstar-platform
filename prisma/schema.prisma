generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  // extensions = [vector]
}

model ContactSubmission {
  id          String            @id @default(cuid())
  name        String
  email       String
  subject     String
  service     String
  message     String
  newsletter  Boolean           @default(false)
  submittedAt DateTime          @default(now())
  ipAddress   String?
  userAgent   String?
  status      ContactStatus     @default(PENDING)
  adminNotes  String?
  respondedAt DateTime?
  respondedBy String?
  responses   ContactResponse[]

  @@map("contact_submissions")
}

model ContactResponse {
  id           String            @id @default(cuid())
  submissionId String
  adminId      String?
  response     String
  responseType ResponseType
  sentAt       DateTime          @default(now())
  submission   ContactSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@map("contact_responses")
}

model NewsletterSubscriber {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?
  isActive       Boolean   @default(true)
  source         String?
  tags           String?

  @@map("newsletter_subscribers")
}

model AdminUser {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String
  role         AdminRole @default(ADMIN)
  createdAt    DateTime  @default(now())
  lastLogin    DateTime?
  passwordHash String
  isActive     Boolean   @default(true)

  @@map("admin_users")
}

model ContactAnalytics {
  id                String   @id @default(cuid())
  date              DateTime @unique @default(now())
  submissions       Int      @default(0)
  newsletterSignups Int      @default(0)
  serviceBreakdown  Json?

  @@map("contact_analytics")
}

/// *
///  * Hero Slides - Dynamic content for homepage hero section
///  * Allows admin to manage carousel slides with custom content
model HeroSlide {
  id             String   @id @default(cuid())
  titleLine1     String
  titleLine2     String
  tagline        String
  description    String
  imageUrl       String
  gradient       String
  buttonGradient String
  buttonBorder   String
  buttonText     String
  buttonHover    String
  isActive       Boolean  @default(true)
  sortOrder      Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdBy      String?
  altText        String?
  projectTitle   String?
  projectDesc    String?

  @@map("hero_slides")
}

/// *
///  * Hero Slideshow Configuration - Global settings for hero carousel behavior
///  * Controls auto-play, transitions, indicators, and timing
model HeroSlideshowConfig {
  id                 String   @id @default(cuid())
  autoPlayEnabled    Boolean  @default(true)
  autoPlayInterval   Int      @default(7000)
  showIndicators     Boolean  @default(true)
  transitionEffect   String   @default("fade")
  transitionDuration Int      @default(700)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  createdBy          String?

  @@map("hero_slideshow_config")
}

model User {
  id                    String             @id @default(cuid())
  email                 String             @unique
  name                  String?
  picture               String?
  workosId              String?            @unique
  tier                  UserTier           @default(GUEST)
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  storageQuota          Int                @default(1073741824)
  storageUsed           Int                @default(0)
  defaultModelId        String?            // User's preferred default AI model
  paidModelUsageToday   Int                @default(0) // Daily usage count for paid models
  paidModelUsageResetAt DateTime?          // When to reset the daily counter
  fileShares            FileShare[]        @relation("SharedByUser")
  receivedShares        FileShare[]        @relation("SharedWithUser")
  files                 File[]
  folders               Folder[]
  googleDriveConfig     GoogleDriveConfig?
  publicPrompts         PublicPrompt[]
  conversations         Conversation[]
  modelUsageStats       UserModelUsage[]   // Track model usage for "most used" sorting

  @@map("users")
}

model File {
  id              String        @id @default(cuid())
  name            String
  originalName    String
  mimeType        String
  size            Int
  path            String
  folderId        String?
  ownerId         String
  storageProvider String        @default("local")
  storagePath     String?
  checksum        String?
  metadata        Json?
  isPublic        Boolean       @default(false)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  shares          FileShare[]
  versions        FileVersion[]
  folder          Folder?       @relation(fields: [folderId], references: [id])
  owner           User          @relation(fields: [ownerId], references: [id])

  @@map("files")
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  path      String
  parentId  String?
  ownerId   String
  color     String?
  icon      String?
  isShared  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  files     File[]
  owner     User     @relation(fields: [ownerId], references: [id])
  parent    Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children  Folder[] @relation("FolderHierarchy")

  @@map("folders")
}

model FileShare {
  id           String          @id @default(cuid())
  fileId       String
  sharedById   String
  sharedWithId String?
  shareType    ShareType       @default(USER)
  permissions  PermissionLevel @default(READ)
  expiresAt    DateTime?
  createdAt    DateTime        @default(now())
  file         File            @relation(fields: [fileId], references: [id])
  sharedBy     User            @relation("SharedByUser", fields: [sharedById], references: [id])
  sharedWith   User?           @relation("SharedWithUser", fields: [sharedWithId], references: [id])

  @@map("file_shares")
}

model FileVersion {
  id          String   @id @default(cuid())
  fileId      String
  version     Int
  size        Int
  checksum    String
  storagePath String
  createdAt   DateTime @default(now())
  file        File     @relation(fields: [fileId], references: [id])

  @@map("file_versions")
}

model StorageAnalytics {
  id            String   @id @default(cuid())
  userId        String?
  date          DateTime @default(now())
  uploads       Int      @default(0)
  downloads     Int      @default(0)
  storageUsed   Int      @default(0)
  bandwidthUsed Int      @default(0)
  fileTypes     Json?

  @@unique([userId, date])
  @@map("storage_analytics")
}

model GoogleDriveConfig {
  id                 String             @id @default(cuid())
  userId             String             @unique
  accessToken        String
  refreshToken       String
  tokenExpiry        DateTime
  enabled            Boolean            @default(false)
  syncDirection      SyncDirection      @default(BIDIRECTIONAL)
  conflictResolution ConflictResolution @default(LOCAL_WINS)
  syncInterval       Int                @default(60)
  folderMappings     Json?
  johnGPTFolderId    String? // Google Drive folder ID for JohnGPT data
  quotaUsed          BigInt? // Bytes used in Google Drive
  quotaLimit         BigInt? // Total Google Drive quota
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  lastSync           DateTime?
  user               User               @relation(fields: [userId], references: [id])

  @@map("google_drive_configs")
}

/// *
///  * JohnGPT Persona - AI personality/mode configurations
///  * Defines different AI assistant personas with unique system prompts and characteristics
model Persona {
  id           String   @id @default(cuid())
  name         String   @unique
  role         String   // e.g., "Creative Partner", "Strategist", "Biblical Counselor"
  description  String
  systemPrompt String   @db.Text
  icon         String   // Emoji or icon identifier
  color        String   // Hex color for UI theming
  isDefault    Boolean  @default(false)
  isActive     Boolean  @default(true)
  sortOrder    Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("personas")
}

/// *
///  * JohnGPT Public Prompt - Community-shared prompt templates
///  * Users can publish their best prompts to share with the community
model PublicPrompt {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text
  description String?
  category    String   // e.g., "Content Creation", "Video Script", "Brand Voice"
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])
  likes       Int      @default(0)
  uses        Int      @default(0)
  isVerified  Boolean  @default(false) // Admin-verified quality prompts
  isActive    Boolean  @default(true)
  tags        String[] // For searching/filtering
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("public_prompts")
}

/// *
///  * JohnGPT Conversation - Hybrid storage model
///  * TIER1-2: Metadata in DB, full messages in Google Drive
///  * TIER3+: Full messages can be stored in DB (messages field)
model Conversation {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  title           String   @default("New Chat")
  messages        Json     @default("[]") // Database is now source of truth
  messageCount    Int      @default(0)
  lastMessageAt   DateTime @default(now())
  
  personaId       String?
  selectedModelId String?

  // Sync metadata
  localVersion    Int      @default(1)
  syncedVersion   Int      @default(0)
  
  // Legacy/Backup fields
  driveFileId     String?
  driveVersion    Int      @default(1)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId, updatedAt])
  @@map("conversations")
}

model DiagnosticHistory {
  id        String           @id @default(cuid())
  type      DiagnosticType
  status    DiagnosticStatus
  timestamp DateTime         @default(now())
  duration  Int?
  title     String
  summary   String
  results   Json
  warnings  Int              @default(0)
  errors    Int              @default(0)

  @@map("diagnostic_history")
}

model DiagnosticConfig {
  id             String    @id @default(cuid())
  autoEnabled    Boolean   @default(true)
  autoInterval   Int       @default(3600000)
  lastRun        DateTime?
  runFullSystem  Boolean   @default(true)
  runAIBenchmark Boolean   @default(true)
  runStorageScan Boolean   @default(true)
  runNetworkTest Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@map("diagnostic_config")
}

model DiagnosticSchedule {
  id          String         @id @default(cuid())
  type        DiagnosticType
  scheduledAt DateTime
  isRecurring Boolean        @default(false)
  interval    Int?
  status      ScheduleStatus @default(PENDING)
  executedAt  DateTime?
  resultId    String?
  createdAt   DateTime       @default(now())
  createdBy   String?

  @@map("diagnostic_schedule")
}

enum ContactStatus {
  PENDING
  PROCESSED
  RESPONDED
  ARCHIVED
}

enum ResponseType {
  EMAIL
  CALL
  MEETING
  NOTE
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum UserTier {
  ADMIN
  TIER3
  TIER2
  TIER1
  GUEST
}

enum ShareType {
  USER
  PUBLIC
  TEAM
}

enum PermissionLevel {
  READ
  WRITE
  ADMIN
}

enum SyncDirection {
  UPLOAD
  DOWNLOAD
  BIDIRECTIONAL
}

enum ConflictResolution {
  LOCAL_WINS
  REMOTE_WINS
  MANUAL
}

enum DiagnosticType {
  FULL_SYSTEM
  AI_BENCHMARK
  HARDWARE_BENCHMARK
  STORAGE_SCAN
  NETWORK_TEST
}

enum DiagnosticStatus {
  PASSED
  WARNINGS
  FAILED
}

enum ScheduleStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

/// *
///  * Site Embeddings - RAG knowledge base for JohnGPT
///  * Stores embedded chunks of site content for semantic search
model SiteEmbedding {
  id           String   @id @default(cuid())
  pageUrl      String   @map("page_url")
  pageTitle    String   @map("page_title")
  contentChunk String   @map("content_chunk") @db.Text
  // embedding    Unsupported("vector(768)")
  metadata     Json?
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([pageUrl], map: "site_embeddings_page_url_idx")
  @@map("site_embeddings")
}

/// Page Navigation - Dedicated table for AI-powered site navigation
model PageNavigation {
  id           String   @id @default(cuid())
  url          String   @unique // e.g., "/services", "/contact", "/dashboard"
  title        String   // e.g., "Services", "Contact Us", "Your Dashboard"
  description  String   // Semantic description for vector search
  category     String   // e.g., "public", "dashboard", "admin"
  requiredTier UserTier @default(GUEST) // Minimum tier needed to access
  isActive     Boolean  @default(true) // Can toggle on/off without deleting
  priority     Int      @default(0) // Higher priority = preferred in search results
  // embedding    Unsupported("vector(768)")
  metadata     Json?    // Extra info: { icon: "ðŸ“§", keywords: ["email", "reach out"] }
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  // Relation: A Page has many Sections
  sections     PageSection[]

  @@index([category])
  @@index([requiredTier])
  @@map("page_navigation")
}

/// Page Section - Sections within pages for scroll-to navigation
/// Each section has its own embedding for semantic search
model PageSection {
  id          String   @id @default(cuid())
  
  // Link to parent page
  pageId      String   @map("page_id")
  page        PageNavigation @relation(fields: [pageId], references: [id], onDelete: Cascade)
  
  // The HTML id attribute (e.g., "pricing-section")
  elementId   String   @map("element_id")
  
  // Human-readable title (e.g., "Pricing")
  title       String
  
  // Semantic description for vector search
  description String
  
  // Display order on the page
  order       Int      @default(0)
  
  // Vector embedding for semantic search
  // embedding   Unsupported("vector(768)")
  
  // Extra metadata (keywords, icons, etc.)
  metadata    Json?
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Prevent duplicate section IDs on the same page
  @@unique([pageId, elementId])
  @@index([elementId])
  @@map("page_sections")
}

/// *
///  * AI Provider - Configuration for AI service providers
///  * Stores API keys (encrypted) and provider settings
model AIProvider {
  id          String    @id @default(cuid())
  name        String    @unique  // "openai", "google", "groq", "anthropic", "openrouter"
  displayName String              // "OpenAI", "Google Gemini", "Groq"
  apiKey      String?   @db.Text  // Encrypted API key (nullable = use env var fallback)
  baseUrl     String?             // Custom base URL for OpenRouter, local models, etc.
  isEnabled   Boolean   @default(true)
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  models      AIModel[]

  @@map("ai_providers")
}

/// *
///  * AI Model - Available AI models with tier requirements
///  * Defines which models are available and access restrictions
model AIModel {
  id            String     @id @default(cuid())
  providerId    String
  provider      AIProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  modelId       String     // Provider's model ID, e.g., "gpt-4o", "gemini-2.5-flash"
  displayName   String     // User-friendly name, e.g., "GPT-4o"
  description   String?    // Brief description of model capabilities
  minTier       UserTier   @default(GUEST)  // Minimum tier required to use this model
  contextWindow Int?       // Token context window size (128000, 1000000, etc.)
  hasVision     Boolean    @default(false)  // Supports image input
  hasImageGen   Boolean    @default(false)  // Can generate images
  isPremium     Boolean    @default(false)  // Counts against daily limit for Tier 1
  isFeatured    Boolean    @default(false)  // Admin-selected to show in top 5
  tags          String[]   // Capability tags: ["creativity", "reasoning", "coding"]
  iconUrl       String?    // URL to provider/model icon
  isDefault     Boolean    @default(false)  // Default model for new conversations
  isActive      Boolean    @default(true)   // Admin can disable without deleting
  sortOrder     Int        @default(0)      // Display order in model selector
  
  // Rate limiting (per-model limits from provider)
  requestsPerMinute   Int?       // Max requests per minute (RPM)
  requestsPerDay      Int?       // Max requests per day  
  tokensPerMinute     Int?       // Max input tokens per minute
  tokensPerDay        Int?       // Max input tokens per day
  maxOutputTokens     Int?       // Max output tokens per request
  
  // Context caps per tier (JSON: {"GUEST": 8000, "TIER1": 32000, "TIER2": null})
  tierContextCaps     Json?      // null = use full context, number = cap at that limit
  
  // Relations
  usageStats    UserModelUsage[]
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@unique([providerId, modelId])
  @@index([minTier])
  @@index([isActive, sortOrder])
  @@index([isFeatured, sortOrder])  // For featured models query
  @@map("ai_models")
}

/// *
///  * User Model Usage - Tracks how often users use each model
///  * Used to show "most used" models in the selector
model UserModelUsage {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  modelId     String
  model       AIModel  @relation(fields: [modelId], references: [id], onDelete: Cascade)
  
  usageCount  Int      @default(1)  // Total times used
  lastUsedAt  DateTime @default(now())
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, modelId])  // One record per user-model pair
  @@index([userId, usageCount])  // For sorting by most used
  @@map("user_model_usage")
}

// ============================================
// PORTFOLIO SYSTEM
// ============================================

enum PortfolioPlatform {
  YOUTUBE
  TIKTOK
  INSTAGRAM
  MANUAL
}

enum PortfolioCategory {
  VIDEO
  WEB
  BRANDING
  OTHER
}

model PortfolioItem {
  id          String   @id @default(cuid())
  
  // External IDs
  externalId  String?  // Platform-specific ID (YouTube video ID, TikTok ID, etc.)
  platform    PortfolioPlatform
  
  // Content
  title       String
  description String?  @db.Text
  aiSummary   String?  @db.Text  // AI-generated summary
  
  // Media
  thumbnailUrl String?
  mediaUrl     String?  // Direct media URL or embed URL
  embedHtml    String?  @db.Text  // Pre-generated embed HTML for iframes
  
  // Metadata
  category    PortfolioCategory @default(VIDEO)
  tags        String[]
  duration    String?  // "4:32" format
  views       Int?
  likes       Int?
  publishedAt DateTime?
  
  // Case Study (optional)
  hasDetailedCaseStudy Boolean @default(false)
  challenge   String?  @db.Text
  solution    String?  @db.Text
  results     String?  @db.Text
  liveUrl     String?
  
  // Ordering & Visibility
  displayOrder Int      @default(0)
  isVisible    Boolean  @default(true)
  isPinned     Boolean  @default(false)
  
  // Cross-platform duplicate tracking
  duplicateGroupId String?  // Items with same ID are duplicates
  isPrimaryVersion Boolean @default(true)  // Only show primary version
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  credits     PortfolioCredit[]
  
  @@unique([platform, externalId])
  @@index([platform])
  @@index([category])
  @@index([duplicateGroupId])
  @@map("portfolio_items")
}

model PortfolioCredit {
  id            String @id @default(cuid())
  portfolioItem PortfolioItem @relation(fields: [portfolioItemId], references: [id], onDelete: Cascade)
  portfolioItemId String
  
  name     String
  role     String
  linkedin String?
  website  String?
  
  @@index([portfolioItemId])
  @@map("portfolio_credits")
}

model PortfolioSyncLog {
  id        String   @id @default(cuid())
  platform  PortfolioPlatform
  status    String   // 'success', 'failed', 'partial'
  itemsAdded Int     @default(0)
  itemsUpdated Int   @default(0)
  errorMessage String?
  syncedAt  DateTime @default(now())

  @@map("portfolio_sync_logs")
}
